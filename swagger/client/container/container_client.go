// Code generated by go-swagger; DO NOT EDIT.

package container

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new container API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for container API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
AddSite adds site

The addSite operation enables you to add a site to a container using an existing Site Template.
*/
func (a *Client) AddSite(params *AddSiteParams, authInfo runtime.ClientAuthInfoWriter) (*AddSiteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddSiteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "addSite",
		Method:             "POST",
		PathPattern:        "/Imports/addSite",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddSiteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*AddSiteOK), nil

}

/*
DeleteContainer deletes a container

The deleteContainer operation enables you to delete a container from IPControl.
*/
func (a *Client) DeleteContainer(params *DeleteContainerParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteContainerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteContainerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteContainer",
		Method:             "DELETE",
		PathPattern:        "/Deletes/deleteContainer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteContainerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteContainerOK), nil

}

/*
DetachContainer detaches a container

The detachContainer operation enables you to detach a device container from one of its parents. The device container must have more than one parent. If the device container has one parent, the deleteContainer operation must be used to delete it from the container hierarchy instead.
*/
func (a *Client) DetachContainer(params *DetachContainerParams, authInfo runtime.ClientAuthInfoWriter) (*DetachContainerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDetachContainerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "detachContainer",
		Method:             "DELETE",
		PathPattern:        "/Deletes/detachContainer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DetachContainerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DetachContainerOK), nil

}

/*
EndExportContainer exports containers

The endExportContainer operation is an optional final step in the series of calls to export containers from IPControl. Invoking this operation enables IPControl to clean up session information.
*/
func (a *Client) EndExportContainer(params *EndExportContainerParams, authInfo runtime.ClientAuthInfoWriter) (*EndExportContainerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEndExportContainerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "endExportContainer",
		Method:             "POST",
		PathPattern:        "/Exports/endExportContainer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &EndExportContainerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EndExportContainerOK), nil

}

/*
ExportContainer exports containers

The exportContainer operation enables you to export containers from IPControl. Before invoking the exportContainer operation, you must use initExportContainer to initialize the API. The response returned from the init operation becomes the input to this operation.
*/
func (a *Client) ExportContainer(params *ExportContainerParams, authInfo runtime.ClientAuthInfoWriter) (*ExportContainerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewExportContainerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "exportContainer",
		Method:             "POST",
		PathPattern:        "/Exports/exportContainer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ExportContainerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ExportContainerOK), nil

}

/*
GetContainerByName gets a container

Retrieve information about a container.
*/
func (a *Client) GetContainerByName(params *GetContainerByNameParams, authInfo runtime.ClientAuthInfoWriter) (*GetContainerByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetContainerByNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getContainerByName",
		Method:             "GET",
		PathPattern:        "/Gets/getContainerByName",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetContainerByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetContainerByNameOK), nil

}

/*
GetContainerParentHierarchy gets a parent container hierarchy

Retrieve a String array containing the fully qualified names of all parents of the named container
*/
func (a *Client) GetContainerParentHierarchy(params *GetContainerParentHierarchyParams, authInfo runtime.ClientAuthInfoWriter) (*GetContainerParentHierarchyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetContainerParentHierarchyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getContainerParentHierarchy",
		Method:             "GET",
		PathPattern:        "/Gets/getContainerParentHierarchy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetContainerParentHierarchyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetContainerParentHierarchyOK), nil

}

/*
ImportContainer imports a container

The importContainer operation enables you to import a container to IPControl. These can be logical containers or device containers. It can also be used to modify an existing container by specifying its id.
*/
func (a *Client) ImportContainer(params *ImportContainerParams, authInfo runtime.ClientAuthInfoWriter) (*ImportContainerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportContainerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "importContainer",
		Method:             "POST",
		PathPattern:        "/Imports/importContainer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImportContainerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImportContainerOK), nil

}

/*
InitExportContainer exports containers

The initExportContainer operation enables you to export containers from IPControl. You can filter the list of containers retrieved. When ParentContainerFullPath is specified in the options array, the service populates the parent container field using the long format, for example: IPControl/Texas/Dallas. When pageSize and firstResultPos are specified, a list of structures is returned as described for the exportContainer operation. Otherwise, the returned structure can be passed on a subsequent exportContainer operation to retrieve results.
*/
func (a *Client) InitExportContainer(params *InitExportContainerParams, authInfo runtime.ClientAuthInfoWriter) (*InitExportContainerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInitExportContainerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "initExportContainer",
		Method:             "POST",
		PathPattern:        "/Exports/initExportContainer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &InitExportContainerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*InitExportContainerOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
