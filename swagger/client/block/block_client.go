// Code generated by go-swagger; DO NOT EDIT.

package block

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new block API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for block API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
DeleteBlock deletes a block

The deleteBlock operation enables you to delete a block from IPControl.
*/
func (a *Client) DeleteBlock(params *DeleteBlockParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteBlockOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteBlockParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteBlock",
		Method:             "DELETE",
		PathPattern:        "/Deletes/deleteBlock",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteBlockReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteBlockOK), nil

}

/*
DetachBlock detaches a block

The detachBlock operation enables you to detach blocks from device containers in IPControl. If an interface address is specified and the block has multiple interface addresses on the specified container, then only the specified interface address will be detached. container must be specified if the block name is not unique, due to overlapping space or naming conventions.
*/
func (a *Client) DetachBlock(params *DetachBlockParams, authInfo runtime.ClientAuthInfoWriter) (*DetachBlockOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDetachBlockParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "detachBlock",
		Method:             "POST",
		PathPattern:        "/Imports/detachBlock",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DetachBlockReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DetachBlockOK), nil

}

/*
GetBlockByIPAddress gets a block by identifying its IP address

Retrieve information about a block by specifying the IP address and, optionally, the container name, block size or block status (if required for unique identification).
*/
func (a *Client) GetBlockByIPAddress(params *GetBlockByIPAddressParams, authInfo runtime.ClientAuthInfoWriter) (*GetBlockByIPAddressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBlockByIPAddressParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getBlockByIpAddress",
		Method:             "GET",
		PathPattern:        "/Gets/getBlockByIpAddress",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetBlockByIPAddressReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBlockByIPAddressOK), nil

}

/*
GetBlockByName gets a block by identifying its name

Retrieve information about a block by specifying the blockname and, optionally, the container name (if required for overlapping space).
*/
func (a *Client) GetBlockByName(params *GetBlockByNameParams, authInfo runtime.ClientAuthInfoWriter) (*GetBlockByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBlockByNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getBlockByName",
		Method:             "GET",
		PathPattern:        "/Gets/getBlockByName",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetBlockByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBlockByNameOK), nil

}

/*
GetDeployedBlockByIPAddressCalculateStats gets an in use deployed block by identifying its IP address include updated utilization statistics

Retrieve information about an In Use/Deployed block by specifying the IP address and, optionally, the container name, block size (if required for unique identification).  The utilization statistics will be generated with up to date information. NOTE: The statistics will NOT be updated in the database.
*/
func (a *Client) GetDeployedBlockByIPAddressCalculateStats(params *GetDeployedBlockByIPAddressCalculateStatsParams, authInfo runtime.ClientAuthInfoWriter) (*GetDeployedBlockByIPAddressCalculateStatsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDeployedBlockByIPAddressCalculateStatsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getDeployedBlockByIpAddressCalculateStats",
		Method:             "GET",
		PathPattern:        "/Gets/getDeployedBlockByIpAddressCalculateStats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDeployedBlockByIPAddressCalculateStatsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDeployedBlockByIPAddressCalculateStatsOK), nil

}

/*
GetDeployedBlockByNameCalculateStats gets an in use deployed block by identifying its name include updated utilization statistics

Retrieve information about an In Use/Deployed block by specifying the blockname and, optionally, the container name (if required for overlapping space).  The utilization statistics will be generated with up to date information.  NOTE: The statistics will NOT be updated in the database.
*/
func (a *Client) GetDeployedBlockByNameCalculateStats(params *GetDeployedBlockByNameCalculateStatsParams, authInfo runtime.ClientAuthInfoWriter) (*GetDeployedBlockByNameCalculateStatsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDeployedBlockByNameCalculateStatsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getDeployedBlockByNameCalculateStats",
		Method:             "GET",
		PathPattern:        "/Gets/getDeployedBlockByNameCalculateStats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDeployedBlockByNameCalculateStatsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDeployedBlockByNameCalculateStatsOK), nil

}

/*
JoinBlock joins blocks

The joinBlock operation enables you to join existing, adjacent blocks into a larger block. The blocks must be in the same container, and of the same type.
*/
func (a *Client) JoinBlock(params *JoinBlockParams, authInfo runtime.ClientAuthInfoWriter) (*JoinBlockOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJoinBlockParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "joinBlock",
		Method:             "POST",
		PathPattern:        "/Imports/joinBlock",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JoinBlockReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JoinBlockOK), nil

}

/*
ModifyBlock modifies a block

The modifyBlock operation enables you to update certain fields in an existing Block. There are 2 parameters in the input structure, 'container' and 'block'. To modify a block, use this call in conjunction with the getBlock operation. First, retrieve the block the getBlock operation. Then, modify the returned structure. Lastly, pass that modified structure to this operation as the 'block' parameter. If the block id is supplied (as it will be following a getBlock), or the block is not in overlapping space, the 'container' parameter is not required.
*/
func (a *Client) ModifyBlock(params *ModifyBlockParams, authInfo runtime.ClientAuthInfoWriter) (*ModifyBlockOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewModifyBlockParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "modifyBlock",
		Method:             "POST",
		PathPattern:        "/Imports/modifyBlock",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ModifyBlockReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ModifyBlockOK), nil

}

/*
SplitBlock splits a block

The splitBlock operation enables you to split an existing block into smaller blocks. If equalSizes is true, the block is split such that all resulting blocks have the targetSize CIDR size. If false, the block is split such that the fewest number of new blocks is created, along with two blocks of targetSize.
*/
func (a *Client) SplitBlock(params *SplitBlockParams, authInfo runtime.ClientAuthInfoWriter) (*SplitBlockOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSplitBlockParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "splitBlock",
		Method:             "POST",
		PathPattern:        "/Imports/splitBlock",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SplitBlockReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SplitBlockOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
