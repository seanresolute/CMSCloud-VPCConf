// Code generated by go-swagger; DO NOT EDIT.

package aggregate_block

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new aggregate block API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for aggregate block API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
DeleteAggregateBlock deletes an aggregate block

The deleteAggregateBlock operation enables you to delete an intermediate level aggregate block from the block hierarchy. By specifying the block to be deleted, the operation will validate and delete the block. It will also adjust the parent block assignments of any child blocks.
*/
func (a *Client) DeleteAggregateBlock(params *DeleteAggregateBlockParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteAggregateBlockOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteAggregateBlockParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteAggregateBlock",
		Method:             "DELETE",
		PathPattern:        "/Deletes/deleteAggregateBlock",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteAggregateBlockReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteAggregateBlockOK), nil

}

/*
ImportAggregateBlock imports an aggregate block

The importAggregateBlock operation enables you to insert an intermediate level aggregate block between existing blocks in the block hierarchy. By specifying a parent block, target block, and a container, the service will handle validating and inserting the desired aggregate block. The service will also adjust the parent block assignments of any would-be child blocks.
*/
func (a *Client) ImportAggregateBlock(params *ImportAggregateBlockParams, authInfo runtime.ClientAuthInfoWriter) (*ImportAggregateBlockOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewImportAggregateBlockParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "importAggregateBlock",
		Method:             "POST",
		PathPattern:        "/Imports/importAggregateBlock",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ImportAggregateBlockReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ImportAggregateBlockOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
